<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>FINH LIFF</title>

  <link rel="icon" href="data:,">
  <link rel="preload" as="style" href="/finh-theme.css?v=4">
  <link rel="stylesheet" href="/finh-theme.css?v=4">

  <script defer src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
</head>
<body>
  <header class="topbar">
  <!-- LEFT: LINE user -->
  <div class="left user" id="lineUser">
    <img id="lineAvatar" class="avatar" alt="" hidden>
    <div class="user-meta">
      <b id="lineName">LINE User</b>
    </div>
  </div>

  <!-- CENTER: Brand -->
  <div class="brand"><img src="./assets/finh_logo.png" alt="FINH"></div>

  <!-- RIGHT: controls -->
  <div class="right">
    <select id="deviceSelect" title="Select device">
      <option value="" selected disabled>Loading devices…</option>
    </select>
    <button id="refreshBtn" class="icon-btn" title="Refresh">⟳</button>
  </div>
</header>

  <section class="dashboard" id="dashboard" hidden>
    <div class="dash-hero">
      <div>
        <h1>Maturity Level</h1>
        <!-- Level + Progress -->
        <div class="dash-level">Level <span id="growthLevelDash" class="level">-</span></div>
        <div class="progress-lite dash-progress">
          <div class="track"><div id="barFillDash" class="fill"></div></div>
          <div class="pct"><span id="pctTopDash">0</span>%</div>
        </div>

        <!-- KPIs -->
        <div class="dash-kpis">
          <!-- Water -->
          <div class="dkpi kpi-water">
            <svg class="kpi-ic" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M12 2s6 6.8 6 10a6 6 0 1 1-12 0C6 8.8 12 2 12 2Z"/>
            </svg>
            <small>Water</small>
            <b id="dkpi-water">—</b>
          </div>

          <!-- pH -->
          <div class="dkpi kpi-ph">
            <svg class="kpi-ic" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
              <path d="M7 3h10M13 3v6l3.6 7.2A2 2 0 0 1 14.8 19H9.2a2 2 0 0 1-1.8-2.8L11 9V3"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M9 13c1.8 1 3.6 1 6 0" stroke-width="2" stroke-linecap="round"/>
            </svg>
            <small>pH Level</small>
            <b id="dkpi-ph">—</b>
          </div>

          <!-- Temp -->
          <div class="dkpi kpi-temp">
            <svg class="kpi-ic" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
              <path d="M14.75 14.78V5.58a3.67 3.67 0 0 0-7.33 0v9.2A4.53 4.53 0 1 0 15.67 17.5a4.53 4.53 0 0 0-.92-2.72Z"
                    stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M11.08 5.58v11" stroke-width="2" stroke-linecap="round"/>
              <path d="M14.75 6.5h2.75M14.75 10.17h2.75M14.75 13.83h2.75"
                    stroke-width="2" stroke-linecap="round"/>
            </svg>
            <small>Temperature (°C)</small>
            <b id="dkpi-temp">—</b>
          </div>
        </div>
      </div>
    </div>

    <!-- Panels -->
    <div class="dash-panels">
      <div class="dash-card growth">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <h3>Growth analytics</h3>
        </div>
        <div class="dash-spark">
          <canvas id="spark" width="800" height="220" aria-label="pH & Temp chart"></canvas>
        </div>
      </div>

      <div class="dash-card controls">
  <div class="controls-head">
    <h3>Controls</h3>
    <small class="muted">ส่งคำสั่งไปยังอุปกรณ์ที่เลือก</small>
  </div>

  <div class="controls-grid">
    <label class="ctrl">
      <div class="ctrl-meta">
        <b>Water turbine</b>
      </div>
      <input type="checkbox" id="ctrl-water" data-relay="relay1">
      <span class="switch" aria-hidden="true"></span>
    </label>

    <label class="ctrl">
      <div class="ctrl-meta">
        <b>Harvest</b>
      </div>
      <input type="checkbox" id="ctrl-harvest" data-relay="relay2">
      <span class="switch" aria-hidden="true"></span>
    </label>

    <label class="ctrl">
      <div class="ctrl-meta">
        <b>Drain</b>
      </div>
      <input type="checkbox" id="ctrl-drain" data-relay="relay3">
      <span class="switch" aria-hidden="true"></span>
    </label>
  </div>

  <div class="ctrl-hint" id="ctrlHint" hidden></div>
</div>

      <div class="dash-card alerts">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <h3>Critical Alerts</h3>
        </div>
        <ul class="dash-alerts" id="dash-alerts">
          <li><span class="ok"></span> Optimal growth</li>
          <li><span class="warn"></span> Low water level</li>
          <li><span class="bad"></span> pH above normal</li>
        </ul>
      </div>

<div class="dash-card harvests">
  <div class="harv-head">
    <h3>Harvest Tracking</h3>
    <div class="harv-toolbar">
      <div class="filters">
        <input type="date" id="hfFrom" title="From date">
        <span class="sep">–</span>
        <input type="date" id="hfTo" title="To date">
        <select id="hfQc" title="QC filter">
          <option value="">QC: All</option>
          <option value="pass">Pass</option>
          <option value="fail">Fail</option>
          <option value="none">No QC</option>
        </select>
        <input id="hfSearch" class="search" placeholder="Search note / id">
      </div>
    </div>
    <div class="harv-summary">
      <div class="chip"><b id="hsCount">0</b><span>Harvests</span></div>
      <div class="chip"><b id="hsWeight">0.00</b><span>kg total</span></div>
      <div class="chip"><b id="hsMoist">—</b><span>avg moisture</span></div>
    </div>
  </div>

  <div class="table-wrap">
    <table class="tbl harv-table" id="harvestTable">
      <thead>
        <tr>
          <th class="sticky">Date</th>
          <th class="sticky">From</th>
          <th class="sticky num">Weight (kg)</th>
          <th class="sticky num">Moisture (%)</th>
          <th class="sticky">QC</th>
          <th class="sticky">Note</th>
        </tr>
      </thead>
      <tbody><!-- filled by JS --></tbody>
    </table>

    <!-- empty / loading states -->
    <div id="harvEmpty" class="empty" hidden>ยังไม่มีรายการเก็บเกี่ยว</div>
    <div id="harvLoading" class="loading" hidden>
      <span class="dot"></span><span class="dot"></span><span class="dot"></span>
      กำลังโหลด…
    </div>
  </div>
</div>

  <!-- Onboarding: Farm setup -->
  <div id="farmModal" class="modal" hidden>
    <div class="modal-card">
      <h3>ตั้งค่าฟาร์มครั้งแรก</h3>

      <label class="f-row">
        <span>ชื่อฟาร์ม</span>
        <input id="farmName" placeholder="เช่น Greenish Farm">
      </label>

      <label class="f-row">
        <span>ค้นหาที่อยู่</span>
        <input id="placeSearch" placeholder="พิมพ์ชื่อสถานที่/ที่อยู่">
      </label>

      <div id="map" class="mapbox"></div>

      <div class="f-ll">
        <input id="lat" placeholder="lat" readonly>
        <input id="lng" placeholder="lng" readonly>
      </div>

      <div class="actions">
        <button id="saveFarm" class="dash-btn">บันทึก</button>
      </div>
    </div>
  </div>

<script>
(async () => {
  'use strict';

  let DEVICES = [];
  let DEVICE_BY_ID = {};

  async function fillLineUser(){
  const $id = (id)=>document.getElementById(id);
  const elName = $id('lineName');
  const elUid  = $id('lineUid');
  const elAvt  = $id('lineAvatar');

  try{
    // ต้อง login ก่อน
    if (!liff.isLoggedIn()) await ensureLogin();

    // 1) พยายามเอาจากโปรไฟล์
    let name, uid, avatar;
    try{
      const prof = await liff.getProfile();
      name   = prof?.displayName;
      uid    = prof?.userId;
      avatar = prof?.pictureUrl;
    }catch(e){
      // 2) Fallback จาก ID Token (ต้องเปิด scope "profile" ใน LIFF Console)
      const idt = liff.getDecodedIDToken?.();
      name   = name || idt?.name || idt?.nickname;
      avatar = avatar || idt?.picture;
      uid    = uid || idt?.sub;
    }

    // 3) Fallback สุดท้าย = uid ที่เราสร้างเอง
    if (!name) name = localStorage.getItem('finh_uid') || 'LINE User';

    if (elName) elName.textContent = name;
    if (elUid && uid){ elUid.textContent = uid; elUid.hidden = false; }
    if (elAvt && avatar){ elAvt.src = avatar; elAvt.hidden = false; }
  }catch(e){
    console.warn('fillLineUser failed', e);
  }
}

  const docIdOf = (d) => d.deviceId || d.id || d.name;
  const nxIdOf  = (d) => d.nexiiotDeviceId || d.deviceId || d.id;
  function toNxId(deviceDocId){ const meta = DEVICE_BY_ID[deviceDocId]; return meta ? nxIdOf(meta) : deviceDocId; }

  function prettyDeviceLabel(d, i){
  const id = docIdOf(d);
  const cand = [d.displayName, d.name, d.title, d.alias].find(s => s && String(s).trim()) || '';
  const looksLikeId = (s) => {
    const t = String(s||'').trim();
    if (!t) return true;
    if (t === id) return true;
    if (t.length > 18) return true;
    const hexish = t.replace(/-/g,'');
    return /^[0-9a-f]{16,}$/i.test(hexish);
  };
  return looksLikeId(cand) ? `Device ${i+1}` : cand;
}

  const LIFF_ID = '2008085765-YDwJrxy9';
  const API_BASE = "https://asia-southeast1-finh-iot-ai.cloudfunctions.net";
  const isAbsUrl = (u) => /^https?:\/\//i.test(u);
  const toApiUrl = (u) => { if (isAbsUrl(u)) return u; if (u.startsWith('/tracking/')) u = u.slice('/tracking'.length); return `${API_BASE}${u}`; };

  /* DOM */
  const $ = (id) => document.getElementById(id);
  const barFillDash = $('barFillDash');
  const pctTopDash = $('pctTopDash');
  const growthLevelDash = $('growthLevelDash');

  /* Utils */
  function showError(err){ console.error(err); }
  function normalizeLevel(lvl){
    if (typeof lvl === 'number') return ['1','2','3','4'][Math.max(0, Math.min(3, lvl))] || String(lvl);
    if (typeof lvl === 'string' && /^\d+$/.test(lvl)) { const n = parseInt(lvl,10); return ['1','2','3','4'][Math.max(0, Math.min(3, n))] || lvl; }
    if (String(lvl).toLowerCase().includes('ready')) return '4';
    return String(lvl || '-');
  }
  function getNum(obj, keys){
    const all = Object.keys(obj || {}), canon = s => String(s||'').toLowerCase();
    for (const k of all){ const ck = canon(k); if (keys.some(q => ck.includes(canon(q)))){ const v = Number(obj[k]); if (!Number.isNaN(v)) return v; } }
    for (const k of all){ if (obj[k] && typeof obj[k] === 'object'){ const v = getNum(obj[k], keys); if (typeof v === 'number') return v; } }
    return null;
  }

  /* LINE Auth */
  const FORCE_SETUP = new URLSearchParams(location.search).get('setup') === '1';
  function stripRedirectUri(){ return location.origin + location.pathname; }
async function ensureLogin(){
  // เผื่อบางเครื่อง liff.ready ต้องรอ
  if (typeof liff?.ready?.then === 'function') { try { await liff.ready; } catch {} }

  if (liff.isLoggedIn()) return;

  const redirectUri = location.origin + location.pathname; // กลับมาหน้าเดิม
  try {
    const opts = { redirectUri };
    if (!liff.isInClient()) opts.withLoginOnExternalBrowser = true; // เปิด browser ภายนอกอัตโนมัติถ้าอยู่นอก LINE
    liff.login(opts);                   // จะ redirect ออกไปเลย
    return new Promise(()=>{});         // กันไม่ให้โค้ดรันต่อ
  } catch (e) {
    alert('LINE login ผิดพลาด กำลังเปิดในเบราว์เซอร์ภายนอก…');
    try { liff.openWindow({ url: redirectUri, external: true }); } catch {}
    return new Promise(()=>{});
  }
}

function getStableUid(){
  // ถ้า LIFF พร้อม ให้ใช้ sub เป็นหลัก แล้ว sync ลง localStorage
  try {
    const sub = window.liff?.getDecodedIDToken?.()?.sub;
    const stored = localStorage.getItem('finh_uid');
    if (sub) {
      if (sub !== stored) localStorage.setItem('finh_uid', sub);
      return sub;
    }
    if (stored) return stored; // ยังไม่ init ก็ใช้ของเดิมไปก่อน
  } catch {}
  // fallback ครั้งแรกเท่านั้น (dev เท่านั้น)
  const fallback = 'dev-user';
  if (!localStorage.getItem('finh_uid')) localStorage.setItem('finh_uid', fallback);
  return localStorage.getItem('finh_uid') || fallback;
}

function buildAuthHeaders(){
  const h = { 'Content-Type':'application/json' };
  let idToken = '', access = '', sub = '';
  try { idToken = sessionStorage.getItem('line_id_token') || (window.liff?.getIDToken?.() || ''); } catch {}
  try { access  = sessionStorage.getItem('line_access_token') || (window.liff?.getAccessToken?.() || ''); } catch {}
  try { sub     = window.liff?.getDecodedIDToken?.()?.sub || ''; } catch {}

  if (idToken && idToken.includes('.')) h['x-line-id-token'] = idToken;
  else if (access) h['x-line-access-token'] = access;

  h['x-dev-uid'] = getStableUid();    // backend ใช้ค่านี้ lookup members
  if (sub) h['x-line-user-id'] = sub; // เผื่อรองรับ header นี้ด้วย

  return h;
}

  /* fetch helpers */
async function authedGet(url, opts={ allow404:false }) {
  const r = await fetch(toApiUrl(url), { headers: buildAuthHeaders() });
  const t = await r.text();
  let j; try { j = JSON.parse(t); } catch { if (opts.allow404 && r.status===404) return null; throw new Error(`HTTP ${r.status}: ${t}`); }
  if (r.status === 404 && (opts.allow404 || j?.error === 'NO_FARM')) return null;
  if (!r.ok || j.errors || j.error) {
    const msg = j?.message ? `${j.error||('HTTP '+r.status)}: ${j.message}` : (j.error || t);
    throw new Error(msg);
  }
  return j;

  }
  async function authedPost(url, body) {
    const r = await fetch(toApiUrl(url), {
      method: 'POST',
      headers: buildAuthHeaders(),
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j; try { j = JSON.parse(t); } catch { throw new Error(`HTTP ${r.status}: ${t}`); }
   if (!r.ok || j.errors || j.error) {
  const msg = j?.message ? `${j.error||('HTTP '+r.status)}: ${j.message}` : (j.error || t);
  throw new Error(msg);
}
return j;

  }
  window.authedGet = authedGet;
  window.authedPost = authedPost;

  async function listDevices(){
    const resp = await authedGet('/devices');  // proxy ผ่าน Functions กัน CORS
    return Array.isArray(resp?.devices) ? resp.devices : [];
  }

  /* Progress & Shadow */
  async function getProgress(docId){
    const sel = document.getElementById('deviceSelect');
    const id = docId || (sel && sel.value) || localStorage.getItem('deviceId');
    if (!id) throw new Error('no device id selected');
    return authedGet(`/getProgress?deviceId=${encodeURIComponent(id)}`);
  }
  async function getDiagValues(docId){
    const st = await authedGet('/diagPollStatus');
    return st?.perDevice?.[docId]?.values || null;
  }
  async function loadProgress(docId){
    const prog = await getProgress(docId);
    const pct = typeof prog.percent === 'number' ? Math.max(0, Math.min(100, prog.percent)) : null;
    const lvl = normalizeLevel(prog.level);
    if (pctTopDash) pctTopDash.textContent = pct!=null ? pct.toFixed(1) : '—';
    if (barFillDash) barFillDash.style.width = pct!=null ? `${pct}%` : '0%';
    if (growthLevelDash) growthLevelDash.textContent = lvl;
    return prog;
  }
  async function loadShadow(deviceDocId){
    const nxId = toNxId(deviceDocId);
    const Q = 'query($deviceid:String!){ shadow(deviceid:$deviceid){ data } }';
    const r = await authedPost('/gql', { query: Q, variables: { deviceid: nxId }});
    const data = r?.data?.shadow?.data || {};
    const ph   = getNum(data, ['soil_ph','pH','ph']);
    const temp = getNum(data, ['temp','temperature','temp_c']);
    updateSeries(deviceDocId, typeof ph==='number'?ph:null, typeof temp==='number'?temp:null);
    drawSpark(deviceDocId);
    return { data, ph, temp };
  }
  async function renderDkpiForDevice(deviceDocId){
    let raw = null, src = 'none';
    try {
      const nxId = toNxId(deviceDocId);
      const Q = 'query($deviceid:String!){ shadow(deviceid:$deviceid){ data } }';
      const r = await authedPost('/gql', { query: Q, variables: { deviceid: nxId }});
      raw = r?.data?.shadow?.data || null;
      if (raw) src = 'gql';
    } catch {}
    if (!raw) {
      try {
        const prog = await getProgress(deviceDocId);
        raw = prog?.values || null;
        if (raw) src = 'progress';
      } catch {}
    }
    if (!raw) {
      try {
        raw = await getDiagValues(deviceDocId);
        if (raw) src = 'diag';
      } catch {}
    }
    const { water, ph, temp } = extractKpis(raw || {});
    document.getElementById('dkpi-water').textContent = formatWater(water);
    document.getElementById('dkpi-ph').textContent    = formatPh(ph);
    document.getElementById('dkpi-temp').textContent  = formatTemp(temp);
    updateSeries(deviceDocId, (typeof ph==='number'?ph:null), (typeof temp==='number'?temp:null));
    drawSpark(deviceDocId);
    localStorage.setItem('deviceId', deviceDocId);
    console.debug('[KPI]', {docId: deviceDocId, src, keys: raw ? Object.keys(raw).slice(0,6) : []});
  }

  /* ===== Controls wiring ===== */

/** แปลง raw shadow/progress -> relay states */
function extractRelays(raw){
  const m = _flattenValues(raw||{});
  const get = (k)=> {
    const v = m[k.toLowerCase()];
    if (v == null) return null;
    const s = String(v).toLowerCase();
    if (s === 'on' || s === '1' || s === 'true') return true;
    if (s === 'off' || s === '0' || s === 'false') return false;
    return null;
  };
  return {
    relay1: get('relay1'),
    relay2: get('relay2'),
    relay3: get('relay3'),
    relay4: get('relay4')
  };
}

/** อัปเดตสถานะสวิตช์จากข้อมูลล่าสุด */
function renderControlsFromRaw(raw){
  const R = extractRelays(raw||{});
  const set = (id,val)=>{
    const el = document.getElementById(id);
    if (el) el.checked = !!val;
  };
  set('ctrl-water',   R.relay1);
  set('ctrl-harvest', R.relay2);
  set('ctrl-drain',   R.relay3);
}

/** ส่งคำสั่งไป backend — พยายาม 2 ทาง: REST แล้ว fallback เป็น GQL */
async function sendControl(relayKey, on){
  const sel = document.getElementById('deviceSelect');
  const deviceDocId = (sel && sel.value) || localStorage.getItem('deviceId');
  if (!deviceDocId) throw new Error('no device selected');

  const nxId = toNxId(deviceDocId);
  const payload = { deviceId: deviceDocId, relay: relayKey, value: on ? 'on' : 'off' };

  // 1) REST: /control/relay (ถ้ามี)
  try {
    await authedPost('/control/relay', payload);
    return { ok:true, via: 'rest' };
  } catch (e) {
    console.warn('[control] REST failed, fallback GQL', e?.message || e);
  }

  // 2) Fallback GQL: พุช patch ใส่ shadow (schema แต่ละที่ต่างกัน—ลองรูปแบบที่พบบ่อย)
  const tries = [
    { q: 'mutation($deviceid:String!,$patch:JSON!){ pushShadow(deviceid:$deviceid, patch:$patch){ ok } }',
      v: { deviceid: nxId, patch: { [relayKey]: on ? 'on' : 'off' } } },
    { q: 'mutation($deviceid:String!,$key:String!,$value:String!){ setRelay(deviceid:$deviceid, key:$key, value:$value){ ok } }',
      v: { deviceid: nxId, key: relayKey, value: on ? 'on':'off' } },
  ];
  for (const t of tries){
    try {
      await authedPost('/gql', { query: t.q, variables: t.v });
      return { ok:true, via: 'gql' };
    } catch(e){}
  }
  throw new Error('control endpoint not available');
}

/** bind switch events */
function bindControlEvents(){
  const bind = (id, relay) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', async ()=>{
      const want = el.checked;
      try{
        document.getElementById('ctrlHint').hidden = false;
        document.getElementById('ctrlHint').textContent = 'Sending…';
        await sendControl(relay, want);
        document.getElementById('ctrlHint').textContent = 'Sent ✔';
        // refresh ค่า shadow ให้กราฟ/ค่าสดด้วย
        const sel = document.getElementById('deviceSelect');
        const docId = (sel && sel.value) || localStorage.getItem('deviceId');
        if (docId) { await renderDkpiForDevice(docId); }
      }catch(e){
        document.getElementById('ctrlHint').textContent = 'Failed to send';
        // revert toggle
        el.checked = !want;
        alert(`ส่งคำสั่งไม่สำเร็จ: ${e?.message||e}`);
      }finally{
        setTimeout(()=>{ const h=document.getElementById('ctrlHint'); if(h) h.hidden=true; }, 1200);
      }
    });
  };
  bind('ctrl-water','relay1');
  bind('ctrl-harvest','relay2');
  bind('ctrl-drain','relay3');
}
bindControlEvents();

  /* Google Maps (พร้อมค่าเริ่มต้น) */
  function waitForMapsReady(){
    return new Promise((resolve, reject)=>{
      if (window.google?.maps) return resolve(true);
      const onReady = ()=>{ window.removeEventListener('gmaps-ready', onReady); resolve(true); };
      window.addEventListener('gmaps-ready', onReady);
      setTimeout(()=> reject(new Error('Google Maps failed to load')), 15000);
    });
  }
  let currentFarm = null, gmap, gmarker, places;
  function initMapOnce(){
    if (gmap) return;
    const el = document.getElementById('map');
    gmap = new google.maps.Map(el, { center:{lat:13.736,lng:100.523}, zoom:6 });
    gmarker = new google.maps.Marker({ map:gmap, draggable:true });
    const latEl = document.getElementById('lat'), lngEl = document.getElementById('lng');
    const setLL = (lat,lng) => { gmarker.setPosition({lat,lng}); gmap.panTo({lat,lng}); latEl.value = lat.toFixed(6); lngEl.value = lng.toFixed(6); };
    setLL(13.736, 100.523); // default BKK
    gmap.addListener('click', (e)=> setLL(e.latLng.lat(), e.latLng.lng()));
    places = new google.maps.places.Autocomplete(document.getElementById('placeSearch'));
    places.addListener('place_changed', ()=>{ const p = places.getPlace(); const ll = p.geometry?.location; if (ll) setLL(ll.lat(), ll.lng()); });
    if (navigator.geolocation){ navigator.geolocation.getCurrentPosition(pos => setLL(pos.coords.latitude, pos.coords.longitude)); }
  }

  /* Formatters & Sparkline (เหมือนเดิม) */
  const formatPh   = p => (p==null || Number.isNaN(+p)) ? '—' : `${(+p).toFixed(1)} pH`;
  const formatTemp = t => (t==null || Number.isNaN(+t)) ? '—' : `${(+t).toFixed(1)}°C`;
  function formatWater(w){ if (w==null || Number.isNaN(+w)) return '—'; const n = +w; if (n <= 1) return `${Math.round(n*100)}%`; if (n <= 100) return `${Math.round(n)}%`; return String(n); }
  function _flattenValues(raw){ const base = raw?.values && typeof raw.values==='object' ? raw.values : raw; const out = {}; (function walk(obj){ Object.keys(obj||{}).forEach(k=>{ const v = obj[k]; if (v && typeof v === 'object' && !Array.isArray(v)) { walk(v); } else { out[String(k).toLowerCase()] = v; } }); })(base||{}); return out; }
  function _pickNumber(map, exactKeys=[], containsKeys=[]){ for (const key of exactKeys){ const v = map[key]; const n = Number(v); if (!Number.isNaN(n)) return n; } outer: for (const k in map){ const lk = k.toLowerCase(); for (const p of containsKeys){ if (lk.includes(p)){ const n = Number(map[k]); if (!Number.isNaN(n)) return n; continue outer; } } } return null; }
  function extractKpis(raw){
    const m = _flattenValues(raw);
    let ph = _pickNumber(m, ['water_ph','soil_ph','ph'], ['_ph']); if (ph != null && (ph <= 0.1 || ph > 14)) ph = null;
    let temp = _pickNumber(m, ['water_ec_temp','water_temp','temperature_in','temp_out','weather_temperature','soil_temperature'], ['temp','temperature','_temp']);
    let water = _pickNumber(m, ['water_percent','water_pct','wl','water_level','level','soil_moisture'], ['water_ec']);
    if (water != null && water <= 1) water = water * 100;
    return { water, ph, temp };
  }
  const SERIES_MAX = 120;
  function seriesKey(deviceId){ return 'series_' + deviceId; }
  function loadSeries(deviceId){ try{ return JSON.parse(localStorage.getItem(seriesKey(deviceId))) || {t:[],ph:[],temp:[]}; }catch{ return {t:[],ph:[],temp:[]}; } }
  function saveSeries(deviceId, s){ localStorage.setItem(seriesKey(deviceId), JSON.stringify(s)); }
  function updateSeries(deviceId, ph, temp){
    if (!deviceId || (ph==null && temp==null)) return;
    const s = loadSeries(deviceId); const now = Date.now();
    if (s.t.length && now - s.t[s.t.length-1] < 50*1000){
      if (typeof ph==='number') s.ph[s.ph.length-1] = ph;
      if (typeof temp==='number') s.temp[s.temp.length-1] = temp;
    }else{
      s.t.push(now); s.ph.push(typeof ph==='number'?ph:null); s.temp.push(typeof temp==='number'?temp:null);
    }
    while (s.t.length > SERIES_MAX){ s.t.shift(); s.ph.shift(); s.temp.shift(); }
    saveSeries(deviceId, s);
  }
  function drawSpark(deviceId){
    const c = document.getElementById('spark'); if (!c) return;
    const rect = c.getBoundingClientRect();
    const cssW = Math.max(1, Math.floor(rect.width));
    const cssH = Math.max(1, Math.floor(rect.height));
    const dpr  = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    if (c.width!==cssW*dpr) c.width = cssW*dpr;
    if (c.height!==cssH*dpr) c.height = cssH*dpr;
    const ctx = c.getContext('2d');
    ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr); ctx.clearRect(0,0,cssW,cssH);
    const s = loadSeries(deviceId); const n = s.t.length; if (!n) return;
    const pad = {l:40,r:10,t:18,b:24}, iw = cssW-pad.l-pad.r, ih = cssH-pad.t-pad.b;
    const clamp = (v,lo,hi)=>Math.min(hi,Math.max(lo,v));
    const phVals = s.ph.filter(v=>typeof v==='number');
    let phMin = phVals.length?Math.min(...phVals):7, phMax = phVals.length?Math.max(...phVals):7;
    if (phMax===phMin){ phMax+=.1; phMin-=.1; }
    const phPad=(phMax-phMin)*.15+.1; phMin=clamp(phMin-phPad,0,14); phMax=clamp(phMax+phPad,.1,14);
    const tVals = s.temp.filter(v=>typeof v==='number');
    let tMin = tVals.length?Math.min(...tVals):25, tMax = tVals.length?Math.max(...tVals):25;
    if (tMax===tMin){ tMax+=.5; tMin-=.5; }
    const tPad=(tMax-tMin)*.15+.5; tMin=Math.max(0,tMin-tPad); tMax=tMax+tPad;
    const xAt=i=>pad.l+(i/Math.max(1,n-1))*iw, yAt=(v,min,max)=>pad.t+(1-((clamp(v,min,max)-min)/(max-min)))*ih;
    const grid='#e5efe933'; const lbl='#ffffffbf'; const phColor='#34d399', tColor='#60a5fa';
    const ctxLine=(arr,min,max,color)=>{ const ctx2=ctx; ctx2.strokeStyle=color; ctx2.lineWidth=2; ctx2.beginPath(); let moved=false;
      for(let i=0;i<n;i++){ const v=arr[i]; if(typeof v!=='number') continue; const x=xAt(i), y=yAt(v,min,max); if(!moved){ctx2.moveTo(x,y); moved=true;} else ctx2.lineTo(x,y); }
      if(moved) ctx2.stroke();
    };
    ctx.strokeStyle=grid; ctx.lineWidth=1;
    for(let g=0; g<=4; g++){ const y=pad.t+g*(ih/4); ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(pad.l+iw,y); ctx.stroke(); }
    ctxLine(s.ph, phMin, phMax, phColor);
    ctxLine(s.temp, tMin, tMax, tColor);
ctx.fillStyle=lbl;
ctx.font='600 12px system-ui,-apple-system,Segoe UI,Roboto';
ctx.textAlign='center';
ctx.fillText(`pH ${phMin.toFixed(1)}–${phMax.toFixed(1)}`, pad.l + iw*0.25, pad.t-6);
ctx.fillText(`Temp ${Math.round(tMin)}–${Math.round(tMax)}°C`, pad.l + iw*0.75, pad.t-6);
  }

  /* Farm onboarding */
async function getMyFarm(){
  try {
    const r = await authedGet('/tracking/myFarm?soft=1', { allow404: true });
    console.debug('[getMyFarm] resp =', r);
    if (!r || r.hasFarm === false) return null;

    const id = r?.farmId || r?.id || r?.farm?.id || r?.farm?.farmId || localStorage.getItem('finh_farm_id');
    if (!id) return null;
    const farm = r?.farm ? { id, ...r.farm } : { id, name: r?.name || r?.farmName, location: r?.location };
    localStorage.setItem('finh_farm_id', id);
    return farm;
  } catch (e) {
    console.warn('[getMyFarm] error', e);
    return null;
  }
}

function showFarmModal(){ const m = document.getElementById('farmModal'); if (m) m.hidden = false; }
function hideFarmModal(){ const m = document.getElementById('farmModal'); if (m) m.hidden = true; }

async function ensureFarmOnce(){
  // 1) ถ้ามี cache farmId แล้ว ให้เชื่อก่อน เพื่อไม่ให้ modal โผล่
  const cachedId = localStorage.getItem('finh_farm_id');
  if (!FORCE_SETUP && cachedId){
    window.currentFarm = { id: cachedId };
    hideFarmModal();

    // ยืนยันกับเซิร์ฟเวอร์เบื้องหลัง
    getMyFarm().then(f => {
      if (f) { window.currentFarm = f; }
      else { localStorage.removeItem('finh_farm_id'); showFarmModal(); }
    }).catch(()=>{});

    return true;
  }

  // 2) ไม่มี cache → ถาม server
  const fromServer = await getMyFarm();
  if (fromServer && !FORCE_SETUP){
    window.currentFarm = fromServer;
    hideFarmModal();
    return true;
  }

  // 3) ยังไม่มี → เปิด modal ให้ตั้งค่า
  await waitForMapsReady();
  initMapOnce();
  showFarmModal();
  return false;
}


  /* Harvest Tracking */
  async function fetchHarvests(limit=50){
    let farmId = currentFarm?.id || localStorage.getItem('finh_farm_id');
    if (!farmId){ currentFarm = await getMyFarm(); farmId = currentFarm?.id || localStorage.getItem('finh_farm_id'); }
    if (!farmId) return [];
    const url = `/tracking/harvests?farmId=${encodeURIComponent(farmId)}&limit=${limit}&includeLineage=1`;
    return (await authedGet(url))?.items || [];
  }
  function fmtDate(ts){
    if (!ts) return '—';
    if (typeof ts === 'string') return ts.split('T')[0];
    if (ts._seconds) return new Date(ts._seconds*1000).toISOString().split('T')[0];
    return String(ts);
  }
  function fromSafe(v){ return v==null ? '—' : String(v); }
  function esc(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
  let _harvestCache = [];       // เก็บข้อมูลดิบล่าสุด
let _harvestSortedDesc = true;

function toISODateOnly(ts){
  if (!ts) return null;
  if (typeof ts === 'string') return ts.split('T')[0];
  if (ts._seconds) return new Date(ts._seconds*1000).toISOString().split('T')[0];
  return null;
}

function applyHarvestFilters(items){
  const from = document.getElementById('hfFrom')?.value || '';
  const to   = document.getElementById('hfTo')?.value   || '';
  const qc   = document.getElementById('hfQc')?.value   || '';
  const q    = (document.getElementById('hfSearch')?.value || '').trim().toLowerCase();

  return (items || []).filter(it => {
    const d = toISODateOnly(it.date);
    if (from && d && d < from) return false;
    if (to && d && d > to) return false;

    const qcVal = String(it.qcResult || '').toLowerCase();
    if (qc === 'pass' && qcVal !== 'pass') return false;
    if (qc === 'fail' && qcVal !== 'fail') return false;
    if (qc === 'none' && qcVal) return false;

    if (q) {
      const hay = [
        it.id, it.code, it.note,
        it.from?.pond, it.from?.tray,
        Array.isArray(it.from?.crops) ? it.from.crops.join(',') : ''
      ].map(v => String(v || '').toLowerCase()).join(' ');
      if (!hay.includes(q)) return false;
    }
    return true;
  });
}

function computeHarvestStats(items){
  const n = items.length;
  let weight = 0, moistSum = 0, moistCnt = 0;
  for (const it of items){
    if (typeof it.weightKg === 'number') weight += it.weightKg;
    if (typeof it.moisture === 'number'){ moistSum += it.moisture; moistCnt++; }
  }
  return {
    count: n,
    weight: weight,
    avgMoist: moistCnt ? (moistSum / moistCnt) : null
  };
}

function qcBadge(qc){
  const v = String(qc || '').toLowerCase();
  if (!v) return '<span class="qc qc-none">—</span>';
  if (v === 'pass' || v === 'ok' || v === 'good') return '<span class="qc qc-pass">Pass</span>';
  if (v === 'fail' || v === 'ng' || v === 'bad') return '<span class="qc qc-fail">Fail</span>';
  return `<span class="qc qc-other">${escapeHtml(String(qc))}</span>`;
}

function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

function renderHarvestTable(data){
  const tbody = document.querySelector('#harvestTable tbody');
  const empty = document.getElementById('harvEmpty');
  const loading = document.getElementById('harvLoading');
  if (!tbody) return;
  const raw = Array.isArray(data?.items) ? data.items : [];
  _harvestCache = raw.slice();

  // sort by date desc/asc
  const sorted = raw.slice().sort((a,b)=>{
    const ad = new Date(toISODateOnly(a.date) || 0).getTime();
    const bd = new Date(toISODateOnly(b.date) || 0).getTime();
    return _harvestSortedDesc ? (bd - ad) : (ad - bd);
  });

  const rows = applyHarvestFilters(sorted);

  // stats
  const stat = computeHarvestStats(rows);
  document.getElementById('hsCount').textContent  = String(stat.count);
  document.getElementById('hsWeight').textContent = stat.weight.toFixed(2);
  document.getElementById('hsMoist').textContent  = (stat.avgMoist==null? '—' : stat.avgMoist.toFixed(1));

  // render
  tbody.innerHTML = '';
  for (const item of rows){
    const tr = document.createElement('tr');
    const fromTxt = item.from
      ? `${item.from.pond ?? '-'} / ${item.from.tray ?? '-'}${Array.isArray(item.from.crops)&&item.from.crops.length ? ' / ' + item.from.crops.join(', ') : ''}`
      : '—';
    const dateCell = toISODateOnly(item.date) || '—';
    const weight   = (item.weightKg!=null ? Number(item.weightKg).toFixed(2) : '—');
    const moist    = (item.moisture!=null ? Number(item.moisture).toFixed(1) : '—');
    const note     = item.note ? escapeHtml(item.note) : '—';

    tr.innerHTML = `
      <td>${dateCell}</td>
      <td>${escapeHtml(fromTxt)}</td>
      <td class="num">${weight}</td>
      <td class="num">${moist}</td>
      <td>${qcBadge(item.qcResult)}</td>
      <td>${note}</td>
    `;
    tbody.appendChild(tr);
  }

  // empty/loading states
  empty.hidden   = rows.length !== 0;
  loading.hidden = true;
}

// hook filters
['hfFrom','hfTo','hfQc','hfSearch'].forEach(id=>{
  const el = document.getElementById(id);
  if (el) el.addEventListener('input', ()=> renderHarvestTable({ items: _harvestCache }));
});

// toggle sort byคลิกหัวคอลัมน์ Date
document.addEventListener('click', (e)=>{
  const th = e.target.closest('th');
  if (!th) return;
  if (th.textContent.trim().toLowerCase() === 'date'){
    _harvestSortedDesc = !_harvestSortedDesc;
    renderHarvestTable({ items: _harvestCache });
  }
});

  document.addEventListener('click', (e)=>{ if (e.target && e.target.id === 'reloadHarvest'){ fetchHarvests().then(d=>renderHarvestTable({items:d})).catch(console.error); } });
  async function refreshHarvestCard(){
  try{
    const loading = document.getElementById('harvLoading');
    const empty   = document.getElementById('harvEmpty');
    if (loading) loading.hidden = false;
    if (empty)   empty.hidden   = true;

    if (!currentFarm?.id){
      currentFarm = await getMyFarm();
      if (!currentFarm?.id){
        if (loading) loading.hidden = true;
        if (empty) empty.hidden = false;
        return;
      }
    }
    const items = await fetchHarvests();
    renderHarvestTable({ items });
  }catch(e){
    console.error(e);
    const loading = document.getElementById('harvLoading');
    const empty   = document.getElementById('harvEmpty');
    if (loading) loading.hidden = true;
    if (empty) empty.hidden = false;
  }
}
  /* Boot */
  window.addEventListener('DOMContentLoaded', async () => {
    try {
await liff.init({ liffId: LIFF_ID });
await ensureLogin();

// เก็บ token + sync uid ให้เร็วที่สุด (ก่อน call API ใด ๆ)
const idToken = liff.getIDToken();
const accessToken = liff.getAccessToken();
if (idToken)    sessionStorage.setItem('line_id_token', idToken);
if (accessToken)sessionStorage.setItem('line_access_token', accessToken);
const decoded = liff.getDecodedIDToken?.();
if (decoded?.sub) localStorage.setItem('finh_uid', decoded.sub);

await fillLineUser();

const hasFarm = await ensureFarmOnce();  // ตอนนี้จะใช้ uid LINE จริงแล้ว
bindFarmSave();

      const sel = $('deviceSelect');

      try {
        DEVICES = await listDevices();
        DEVICE_BY_ID = Object.fromEntries(DEVICES.map(d => [docIdOf(d), d]));
      } catch (e) { showError(e); }

if (sel){
  sel.innerHTML = '';
  if (DEVICES.length === 0){
    const op = document.createElement('option');
    op.value=''; op.textContent='No device';
    sel.appendChild(op);
  } else {
    DEVICES.forEach((d, i) => {
      const id = docIdOf(d);
      const op = document.createElement('option');
      op.value = id;                              // ใช้ id จริงไว้ยิง API
      op.textContent = prettyDeviceLabel(d, i);   // ← ป้ายสั้น (Device N)
      op.title = d.name || d.title || nxIdOf(d) || id;  // hover เห็นรหัสเต็ม
      sel.appendChild(op);
    });
    const saved = localStorage.getItem('deviceId');
    const hasSaved = saved && [...sel.options].some(o => o.value === saved);
    sel.value = hasSaved ? saved : docIdOf(DEVICES[0]);
    localStorage.setItem('deviceId', sel.value);
  }
}

      window.refreshAll = async function refreshAll(){
        const sel = document.getElementById('deviceSelect');
        const docId = (sel && sel.value) || localStorage.getItem('deviceId');
        if (!docId) return;
        await Promise.all([ renderDkpiForDevice(docId), loadProgress(docId) ]);
        const dash = document.getElementById('dashboard');
        if (dash) dash.hidden = false;
        await refreshHarvestCard();
      }

      if (sel){
        sel.onchange = async () => { localStorage.setItem('deviceId', sel.value); await refreshAll(); };
      }
      $('refreshBtn') && ($('refreshBtn').onclick = refreshAll);

      await refreshAll();
      setInterval(() => { const sel2 = document.getElementById('deviceSelect'); if (!sel2?.value) return; refreshAll().catch(showError); }, 60000);
    } catch (e) {
      showError(e);
    }

  const refreshBtnEl = document.getElementById('refreshBtn');
  async function refreshAllWithSpin(){
  try {
    refreshBtnEl?.classList.add('spin');
    await refreshAll();
  } finally {
    refreshBtnEl?.classList.remove('spin');
  }
}
if (refreshBtnEl) refreshBtnEl.onclick = refreshAllWithSpin;

function bindFarmSave(){
  const btn = document.getElementById('saveFarm');
  if (!btn || btn.dataset.bound === '1') return;

  btn.dataset.bound = '1';
  btn.onclick = async () => {
    const name = (document.getElementById('farmName')?.value || '').trim();
    const lat  = Number((document.getElementById('lat')?.value || '').trim());
    const lng  = Number((document.getElementById('lng')?.value || '').trim());
    const address = (document.getElementById('placeSearch')?.value || '').trim() || null;

    if (!name || !Number.isFinite(lat) || !Number.isFinite(lng)) {
      alert('กรอกชื่อฟาร์มและตำแหน่งให้ครบ (lat/lng ต้องเป็นตัวเลข)');
      return;
    }

    try{
      const created = await authedPost('/tracking/createOrJoinFarm', { name, lat, lng, address });
      const newId = created?.farmId || created?.farm?.id;
      if (newId) localStorage.setItem('finh_farm_id', newId);
      window.currentFarm = created?.farm || { id: newId, name, location: { lat, lng, address } };
      document.getElementById('farmModal').hidden = true;

      // เรียก global เพื่อโหลด devices/KPI/harvest ใหม่
      await window.refreshAll();
    }catch(e){
      console.error('[createOrJoinFarm] failed', e);
      alert(`สร้างฟาร์มไม่สำเร็จ: ${e?.message || e}`);
    }
  };
}

  });
})();

</script>

<script> window.__gmapsReady = () => window.dispatchEvent(new Event('gmaps-ready')); </script>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA2Gx7cUFVTHVR65w371mqgkUCWNlO1SgY&libraries=places&loading=async&callback=__gmapsReady"></script>
</body>
</html>